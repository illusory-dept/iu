; list.iu

(define nil? (lambda (x) (eq x '())))
(define let1 (lambda (f a b) (f a b))) ; two-arg let: (let1 f a b) => (f a b)

(define head    (lambda (xs) (if (nil? xs) #nil (car xs))))
(define tail    (lambda (xs) (if (nil? xs) '()  (cdr xs))))
(define safe-car head)
(define safe-cdr tail)

; Length (tail-recursive)
(define length-acc
  (lambda (xs n)
    (if (nil? xs) n (length-acc (cdr xs) (+ n 1)))))

(define length (lambda (xs) (length-acc xs 0)))

; Fold left/right
(define foldl
  (lambda (f z xs)
    (if (nil? xs) z (foldl f (f z (car xs)) (cdr xs)))))

(define foldr
  (lambda (f z xs)
    (if (nil? xs) z (f (car xs) (foldr f z (cdr xs))))))

; Map / Filter (where)
(define map
  (lambda (f xs)
    (if (nil? xs) '() (cons (f (car xs)) (map f (cdr xs))))))

(define where
  (lambda (pred xs)
    (cond ((nil? xs) '())
          ((pred (car xs)) (cons (car xs) (where pred (cdr xs))))
          (else (where pred (cdr xs))))))

; Any / All
(define any
  (lambda (pred xs)
    (cond ((nil? xs) #nil)
          ((pred (car xs)) #t)
          (else (any pred (cdr xs))))))

(define all
  (lambda (pred xs)
    (cond ((nil? xs) #t)
          ((pred (car xs)) (all pred (cdr xs)))
          (else #nil))))

; Contains (deep equality)
(define contains
  (lambda (x xs)
    (cond ((nil? xs) #nil)
          ((eq x (car xs)) #t)
          (else (contains x (cdr xs))))))

; Take / Drop with guards
(define take
  (lambda (n xs)
    (cond ((or (<= n 0) (nil? xs)) '())
          (else (cons (car xs) (take (- n 1) (cdr xs)))))))

(define drop
  (lambda (n xs)
    (cond ((nil? xs) '())
          ((<= n 0) xs)
          (else (drop (- n 1) (cdr xs))))))

; Reverse (tail-recursive)
(define rev-acc
  (lambda (acc xs)
    (if (nil? xs) acc (rev-acc (cons (car xs) acc) (cdr xs)))))

(define reverse (lambda (xs) (rev-acc '() xs)))

; Chunk list into groups of n (last group may be shorter)
(define group
  (lambda (n xs)
    (cond ((<= n 0) '())
          ((nil? xs) '())
          (else (cons (take n xs) (group n (drop n xs)))))))

; Unique (stable): keep first occurrence, drop duplicates
(define unique
  (lambda (xs)
    (if (nil? xs) '()
      (let1 (lambda (h t)
              (if (contains h t)
                  (unique t)
                  (cons h (unique t))))
            (car xs) (cdr xs)))))

; Flatten (full, recursive)
(define flatten
  (lambda (xs)
    (cond ((nil? xs) '())
          ((nil? (car xs)) (flatten (cdr xs)))
          ((atom (car xs)) (cons (car xs) (flatten (cdr xs))))
          (else (append (flatten (car xs)) (flatten (cdr xs)))))))

; Append / Concat
(define append
  (lambda (xs ys)
    (if (nil? xs) ys (cons (car xs) (append (cdr xs) ys)))))

(define concat
  (lambda (xss)
    (foldl append '() xss)))

; Zip (stop at shortest)
(define zip
  (lambda (xs ys)
    (cond ((or (nil? xs) (nil? ys)) '())
          (else (cons (list (car xs) (car ys))
                      (zip (cdr xs) (cdr ys)))))))

; ZipWith f (stop at shortest)
(define zipWith
  (lambda (f xs ys)
    (cond ((or (nil? xs) (nil? ys)) '())
          (else (cons (f (car xs) (car ys))
                      (zipWith f (cdr xs) (cdr ys)))))))

; Range: [start, end) with positive or negative step (default step=1)
(define range3
  (lambda (start end step)
    (cond ((= step 0) '())
          ((and (> step 0) (>= start end)) '())
          ((and (< step 0) (<= start end)) '())
          (else (cons start (range3 (+ start step) end step))))))

(define range
  (lambda (start end) (range3 start end 1)))

; Folds-based aggregates
(define sum     (lambda (xs) (foldl + 0 xs)))
(define product (lambda (xs) (foldl * 1 xs)))

; Minimum / Maximum of a non-empty list (#nil for empty)
(define minimum
  (lambda (xs)
    (if (nil? xs) #nil
      (foldl (lambda (m x) (if (< x m) x m)) (car xs) (cdr xs)))))

(define maximum
  (lambda (xs)
    (if (nil? xs) #nil
      (foldl (lambda (m x) (if (> x m) x m)) (car xs) (cdr xs)))))

; Find / index-of (#nil when not found)
(define find
  (lambda (pred xs)
    (cond ((nil? xs) #nil)
          ((pred (car xs)) (car xs))
          (else (find pred (cdr xs))))))

(define index-of
  (lambda (x xs)
    (let rec
      (lambda (ys i)
        (cond ((nil? ys) #nil)
              ((eq x (car ys)) i)
              (else (rec (cdr ys) (+ i 1))))))
    (rec xs 0)))

(define repeat-to
  (lambda (xs n)
    (if (or (<= n 0) (nil? xs))
        '()
        (append xs (repeat-to xs (- n (length xs)))))))

(define cycle-to
  (lambda (xs n)
    (if (nil? xs) '()
        (take n (repeat-to xs n)))))

; Unary broadcast: apply f to every scalar, descending into nested lists
(define bmap
  (lambda (f x)
    (if (atom x)
        (f x)
        (map (lambda (e) (bmap f e)) x))))

; Binary broadcast, cycling + nested recursion
(define bzipWith
  (lambda (f a b)
    (cond
      ((and (atom a) (atom b)) (f a b))
      ((atom a) (map (lambda (y) (bzipWith f a y)) b))
      ((atom b) (map (lambda (x) (bzipWith f x b)) a))
      (else
        (zipWith (lambda (x y) (bzipWith f x y))
                 (cycle-to a (max (length a) (length b)))
                 (cycle-to b (max (length a) (length b))))))))

; Examples:
;   (bmap (lambda (x) (* x x)) '((1 2) (3 4)))         ; ((1 4) (9 16))
;   (bzipWith (lambda (x y) (+ x y)) '(1 2 3) '(10))   ; (11 12 13)
;   (bzipWith (lambda (x y) (^ x y)) '(2 3 4) '(2 3))  ; (4 27 16)

; Merge two sorted lists according to comparator cmp
(define merge
  (lambda (cmp left right)
    (cond
      ((nil? left)  right)
      ((nil? right) left)
      ((cmp (car left) (car right))
       (cons (car left) (merge cmp (cdr left) right)))
      (else
       (cons (car right) (merge cmp left (cdr right)))))))

; Split list into two halves (alternating distribution), tail-rec
(define split-acc
  (lambda (xs a b toggle)
    (cond
      ((nil? xs) (list (reverse a) (reverse b)))
      (toggle (split-acc (cdr xs) (cons (car xs) a) b #nil))
      (else   (split-acc (cdr xs) a (cons (car xs) b) #t)))))

(define split
  (lambda (xs) (split-acc xs '() '() #t)))

; Mergesort (stable)
(define mergesort
  (lambda (cmp xs)
    (if (or (nil? xs) (nil? (cdr xs))) xs
        (merge cmp
               (mergesort cmp (car (split xs)))
               (mergesort cmp (car (cdr (split xs))))))))

; helpers
(define sort      (lambda (xs) (mergesort (lambda (a b) (<= a b)) xs)))
(define sort-desc (lambda (xs) (mergesort (lambda (a b) (>  a b)) xs)))
(define sort-by
  (lambda (key-f xs)
    (mergesort (lambda (a b) (<= (key-f a) (key-f b))) xs)))

; Examples:
;   (sort '(4 1 3 2 2))                     ; (1 2 2 3 4)
;   (sort-desc '(4 1 3 2 2))                ; (4 3 2 2 1)
;   (sort-by car '((2 x) (1 y) (2 a)))      ; ((1 y) (2 x) (2 a))

; end
